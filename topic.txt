Data Structures
=============
* String

* Array

* Linked List

* Stack
    - The nature of the stack is that bottom items will never be touched until the top one is poped out. If needed, you can store some "so far" value along with the value in the stack, for example: "minimum value so far in the stack".

* Queue

* Heap

* Hashtable
    - TODO Understand how it is implemented

* Tree
    - Binary Search Tree
    - Red-Black Tree
    - AVL Tree

* Graph
    - Directional vs. un-directional
    - Trie

Algorithms
============
* Dynamic Programming
    - Top-down: Recursion + memoization, store resolved subproblems somwhere to avoid duplication
    - Bottom-up: Solve all subproblems first and get the needed answer from store
      (Sometimes in order to build from smallest, need to loop range(N - 1, -1, -1))
    - There is even bi-directional DP, where you construct such an array from both sides.
    - Most of times, dp[i][j] can already represent the result. But sometimes, such as problem 718, the result is max of all dp[i][j]
    - After finishing a DP solution, think if keeping every DP point is needed. Maybe just track "max so far" or "min so far" is good enough

* Two Pointers
    - TODO

* Binary Search

* Sort

* Bit manipulation

* DFS
    - store some information and return as useful info for the problem, such as height/depth

* BFS
    - Normal tree only can BFS childs. But can DFS a tree first to mark parents, and then can do BFS on childs and parents at the same time

* Disjoint Set / Union Find
The idea is to partition given relationships (connections), such as find connected components of a Graph
    - Use a tree to store representatives of each group (each group start with using itself as representative)
    - [Optional] Can keep track of group information at the same time, such as group size or group members
    - Define `find` and `union` functions:
        - find
            - Given a node, find the representative (recursive calls to find itself)
        - union
            - Given two nodes, find their representatives repespectively
            - If they have same representative, they are already grouped
            - If not, choose one group and merge into the other (if group size is available, merge the smaller one into bigger one)
    
* Divide and Conquer
    - Binary Search
    - Merge k sorted lists

* Backtracking
    - Backtracking is an algorithm for finding all solutions by exploring all potential candidates.

* Quick Select
    - Find kth smallest element
